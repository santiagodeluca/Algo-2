\documentclass[10pt,a4paper]{article}
\usepackage{amssymb}

\input{AEDmacros}
\usepackage{caratula} % Version modificada para usar las macros de algo1 de ~> https://github.com/bcardiff/dc-tex


\titulo{Trabajo p\'actico 1}
\subtitulo{Especificaci\'on y WP}

\fecha{\today}

\materia{Materia de la carrera}
\grupo{FOREJOLKBXQRUOORILHN}

\integrante{De Luca, Santiago Leonel}{4/24}{santidelu510@gmail.com}
\integrante{Lopez, Leandro}{30/24}{lean4405@gmail.com}
\integrante{Cataldi Gagliardi, Franco}{317/24}{franco-cataldi@hotmail.com}
\integrante{Lopez, Ingrid Raquel Gloria}{529/24}{lopezingrid343@gmail.com}
% Pongan cuantos integrantes quieran

% Declaramos donde van a estar las figuras
% No es obligatorio, pero suele ser comodo
\graphicspath{{../static/}}

\begin{document}

\maketitle

\section{Especifiación}
\subsection{Ejercicio 1}

\begin{proc}{grandesCiudades}{\In ciudades : \TLista{Ciudad}}{\TLista{Ciudad}}
	\requiere{noHayNombresRepetidos(ciudades) \land habitantesNoNegativos(ciudades)}
	\asegura{C \in res \iff (C \in ciudades \land C.habitantes > 50.000)}
\end{proc}

\pred{noHayNombresRepetidos}{listaDeCiudades : \TLista{Ciudad}}
{\paraTodo[unalinea]{i, j}{\ent}{(0 \le i, j < |listaDeCiudades| \land i \neq j)  \implicaLuego  (ciudades[i].nombre \neq ciudades[j].nombre)\\}}

\pred{habitantesNoNegativos}{listaDeCiudades : \TLista{Ciudad}}
{\paraTodo[unalinea]{elemento}{Ciudad}{elemento \in listaDeCiudades \implicaLuego elemento.habitantes \ge 0}}

\subsection{Ejercicio 2}

\begin{proc}{sumaDeHabitantes}{\In menoresDeCiudades : \TLista{Ciudad}, \In mayoresDeCiudades : \TLista{Ciudad}}{\TLista{Ciudad}}
	\requiere{noHayNombresRepetidos(mayoresDeCiudades) \land habitantesNoNegativos(mayoresDeCiudades) \land \\
	noHayNombresRepetidos(menoresDeCiudades) \land habitantesNoNegativos(menoresDeCiudades)}
	\requiere{|menoresDeCiudades| = |mayoresDeCiudades| \yLuego \\ mismosNombres(menoresDeCiudades, mayoresDeCiudades)}
	\asegura{|res| = |menoresDeCiudades| \yLuego (mismosNombres(res, menoresDeCiudades) \land \\ habitantesSumados(res, menoresDeCiudades, mayoresDeCiudades))}
\end{proc}

\pred{mismosNombres}{listaDeCiudades1 : \TLista{Ciudad}, listaDeCiudades2 : \TLista{Ciudad}}
{\paraTodo[unalinea]{i}{\ent}{0 \le i < |listaDeCiudades1| \implicaLuego \\
 \existe[unalinea]{j}{\ent}{0 \le j < |listaDeCiudades2| \yLuego listaDeCiudades1[i].nombre = listaDeCiudades2[j].nombre}}}

\pred{habitantesSumados}{listaSuma : \TLista{Ciudad}, listaMenores : \TLista{Ciudad}, listaMayores : \TLista{Ciudad}}
{\paraTodo[unalinea]{i}{\ent}{0 \le i < |listaSuma| \implicaLuego
 \existe[unalinea]{j, k}{\ent}{0 \le j, k < |listaMenores| \yLuego \\ 
 (ciudadSuma[i].nombre = ciudadMenor[j].nombre \land ciudadSuma[i].nombre = ciudadMenor[k].nombre \land \\
 ciudadSuma[i].habitantes = ciudadMenor[j].habitantes + ciudadMayor[k].habitantes)}}}

\subsection{Ejercicio 3}

\begin{proc}{hayCamino}{\In distancias : \TLista{\TLista{\ent}}, \In desde : \ent, \In hasta : \ent}{\bool}
	\requiere{esCuadrada(distancias) \yLuego \\ (esSimetrica(distancias) \land \\ diagonalEsCero(distancias) \land \\ valoresNoNegativos(distancias))}
	\asegura{res = True \iff \existe[unalinea]{camino}{\TLista{\ent}}{|camino| \geq 2 \land esCamino(distancias, desde, hasta, camino)}}
\end{proc}

\pred{esCuadrada}{matriz : \TLista{\TLista{\ent}}}
{\paraTodo[unalinea]{fila}{\ent}{0 \leq fila < |matriz| \implicaLuego |matriz[fila]| = |matriz|}}

\pred{esSimetrica}{matriz : \TLista{\TLista{\ent}}}
{\paraTodo[unalinea]{i, j}{\ent}{0 \leq i, j < |matriz| \implicaLuego matriz[i][j] = matriz[j][i]}}

\pred{diagonalEsCero}{matriz : \TLista{\TLista{\ent}}}
{\paraTodo[unalinea]{i}{\ent}{0 \leq i < |matriz| \implicaLuego matriz[i][i] = 0}}

\pred{valoresNoNegativos}{matriz : \TLista{\TLista{\ent}}}
{\paraTodo[unalinea]{i, j}{\ent}{0 \leq i, j < |matriz| \implicaLuego matriz[i][j] \ge 0}}

\pred{esCamino}{distancias : \TLista{\TLista{\ent}}, desde : \ent, hasta : \ent, camino : \TLista{\ent}}
{ciudadesValidas(camino, |distancia|) \yLuego \\
(paresConectados(distancias, camino) \land \\
camino[0] = desde \land\\
camino[|camino| - 1] = hasta)} 

\pred{paresConectados}{distancias : \TLista{\TLista{\ent}}, camino : \TLista{\ent}}
{\paraTodo[unalinea]{i}{\ent}{0 \leq i < |camino| - 1 \implicaLuego distancias[camino[i]][camino[i + 1]] > 0}}

\pred{ciudadesValidas}{camino : \TLista{\ent}, numeroDeCiudades : \ent}
{\paraTodo[unalinea]{i}{\ent}{0 \leq i < |camino| \implicaLuego camino[i] < numeroDeCiudades}}


\subsection{Ejercicio 4}

Para este ejercicio usaremos que para cualquier matriz $M$ que cumpla que $M = PDP^{-1}$ con P una matriz y 
D una matriz diagonal, es decir, que todos sus valores son cero menos los de su diagonal, se cumple que la diagonal
de D tiene los autovalores de la matriz $M$ y por lo tanto $M^{n} = PD^{n}P^{-1}$. \\
Notar que no todas las matrices son diagonalizables, pero sí lo son aquellas que son cuadradas y simétricas,
es decir, que verifican $M = M^{T}$. Todas las matrices que se introducen a este programa lo son (por consigna y por requiere).

\begin{proc}{cantidadCaminosNSaltos}{\Inout conexi\'on : \TLista{\TLista{\ent}}, \In n : \ent}{}
	\requiere{conexi\acute{o}n = C_{0}}
	\requiere{esCuadrada(conexi\acute{o}n) \yLuego \\ (esSimetrica(conexi\acute{o}n) \land diagonalEsCero(conexi\acute{o}n) \land todosCerosOUnos(conexi\acute{o}n))}
	\asegura{\existe[]{P, PInversa, diagonal, diagonalElevada}{\TLista{\TLista{\ent}}}{(|C_{0}| = |P| \land
	|C_{0}| = |PInversa| \land |C_{0}| = |diagonal| \land |C_{0}| = |diagonalElevada| \land \\
	esCuadrada(P) \land esCuadrada(PInversa) \land esCuadrada(diagonal) \land esCuadrada(diagonalElevada)) \yLuego \\
	esInversa(P, PInversa) \land \\
	esDiagonal(diagonal) \land \\
	esDiagonal(diagonalElevada) \land \\
	esDiagonalElevada(diagonal, diagonalElevada, n) \land \\
	esProductoTripleDeMatrices(P, diagonal, PInversa, C_{0}) \land \\
	esProductoTripleDeMatrices(P, diagonalElevada, PInversa, conexi\acute{o}n)}}
\end{proc}

\vspace{0.3cm}

\pred{todosCerosOUnos}{matriz : \TLista{\TLista{\ent}}}
{\paraTodo[unalinea]{i, j}{\ent}{0 \leq i, j < |matriz| \implicaLuego (matriz[i][j] = 0 \lor matriz[i][j] = 1)}}

\vspace{0.3cm}

Para el siguiente predicado usaremos que $A*A^{-1} = I$ donde $I$ es la matriz identidad.

\pred{esInversa}{matrizOriginal : \TLista{\TLista{\ent}}, matrizInversa : \TLista{\TLista{\ent}}}
{\paraTodo[unalinea]{i, j}{\ent}{0 \leq i, j < |matrizOriginal| \implicaLuego \\ 
((i = j \land \sum\nolimits_{k=0}^{|matrizOriginal| - 1} (matrizOriginal[i][k] * matrizInversa[k][j]) = 1) \lor \\
(i \neq j \land \sum\nolimits_{k=0}^{|matrizOriginal| - 1} (matrizOriginal[i][k] * matrizInversa[k][j]) = 0))}}

\pred{esDiagonal}{matriz : \TLista{\TLista{\ent}}}
{\paraTodo[unalinea]{i, j}{\ent}{(0 \leq i, j < |matriz| \land i \neq j) \implicaLuego matriz[i][j] = 0}}

\pred{esDiagonalElevada}{matrizDiagonal : \TLista{\TLista{\ent}}, matrizDiagonalElevada : \TLista{\TLista{\ent}}, n : \ent}
{\paraTodo[unalinea]{i}{\ent}{0 \leq i < |matrizDiagonal| \implicaLuego matrizDiagonalElevada[i][i] = (matrizDiagonal[i][i])^{n}}}

\pred{esProductoDeMatrices}{matrizFactor1 : \TLista{\TLista{\ent}}, matrizFactor2 : \TLista{\TLista{\ent}}, matrizProducto : \TLista{\TLista{\ent}}}
{\paraTodo[unalinea]{i, j}{\ent}{0 \leq i, j < |matrizProducto| \implicaLuego \\ 
(matrizProducto[i][j] = \sum\nolimits_{k=0}^{|matrizProducto| - 1} (matrizFactor1[i][k] * matrizFactor2[k][j]))}}

\pred{esProductoTripleDeMatrices}{matrizFactor1 : \TLista{\TLista{\ent}}, matrizFactor2 : \TLista{\TLista{\ent}}, matrizFactor3 : \TLista{\TLista{\ent}},
matrizProducto : \TLista{\TLista{\ent}}}
{\existe[unalinea]{matrizAuxiliar}{\TLista{\TLista{\ent}}}{(esCuadrada(matrizAuxiliar) \land |matrizAuxiliar| = |matrizFactor1|) \yLuego \\
(esProductoDeMatrices(matrizFactor1, matrizFactor2, matrizAuxiliar) \land \\
esProductoDeMatrices(matrizAuxiliar, matrizFactor3, matrizProducto))}}

\subsection{Ejercicio 5}

\begin{proc}{caminoM\'inimo}{\In origen : \ent, \In destino : \ent, \In distancias : \TLista{\TLista{\ent}}}{\TLista{\ent}}
	\requiere{esCuadrada(distancias) \yLuego \\ (esSimetrica(distancias) \land \\ diagonalEsCero(distancias) \land \\ valoresNoNegativos(distancias))}
	\asegura{esCamino(distancias, origen, destino, res) \implicaLuego \\
	(\paraTodo[unalinea]{camino}{\TLista{\ent}}{esCamino(distancias, origen, destino, camino) \implicaLuego \\
	distanciaRecorrida (camino, distancias) \ge distanciaRecorrida (res, distancias)})}
	\asegura{\neg esCamino(distancias, origen, destino, res) \implicaLuego res = \textlangle \textrangle}
	
	\vspace{0.3cm}

	\aux{distanciaRecorrida}{camino : \TLista{\ent}, distancias : \TLista{\TLista{\ent}}}{\ent} 
	{\\ \sum\nolimits_{i=0}^{|camino| - 2} (distancias[camino[i]][camino[i + 1]])}
	
\end{proc}

\section{Demostraciones de correctitud}
\subsection{Ejercicio 1}
Para demostrar la correctitud de la implementaci\'on con respecto a la especificaci\'on utilizaremos
el teorema del invariante y el teorema de terminaci\'on. Con respecto a nuestro programa, llamamos:
\vspace{0.3cm}\\
$P_{c} \equiv \{i = 0 \land res = 0\}$\\
$Q_{c} \equiv \{res = \sum\nolimits_{j=0}^{|ciudades| - 1} ciudades[j].habitantes\}$\\
$B \equiv \{i < |ciudades|\}$\\
$\neg B \equiv \{i \ge |ciudades|\}$\\
$S1 \equiv res := res + ciudades[i].habitantes$\\
$S2 \equiv i := i + 1$\\
$S \equiv S1; S2$
\vspace{0.3cm}


Proponemos el siguiente invariante: \\
\begin{equation}
	I \equiv \{0 \le i \le |ciudades| \land res = \sum\nolimits_{j=0}^{i - 1} ciudades[j].habitantes\}
\end{equation}

\begin{enumerate} \setlength\itemsep{0cm}
	\item $P_{c} \implies I$\\
	$(i = 0 \land res = 0) \implies (0 \le i \le |ciudades| \land res = \sum\nolimits_{j=0}^{i - 1} ciudades[j].habitantes)$
	\begin{itemize}
		\item $i = 0 \implies 0 \le 0 \le |ciudades| \ \checkmark$ 
		\item $i = 0 \implies res = \sum\nolimits_{j=0}^{- 1} ciudades[j].habitantes \implies res = 0 \ \checkmark$
	\end{itemize}
	\item $\{I \land B\}S\{I\} \iff \{I \land B\} \implies wp(S,I)$
	\vspace{0.3cm}\\
	Buscamos $wp(S, I) \equiv\\ 
	\equiv wp(S1;S2, I) \\
	\overset{\text{AX3}}{\equiv} wp(S1, wp(S2, I))\\
	\equiv wp(S1, wp(i := i + 1, 0 \le i \le |ciudades| \land res = \sum\nolimits_{j=0}^{i - 1} ciudades[j].habitantes))\\
	\overset{\text{AX1}}{\equiv} wp(S1, def(i + 1) \yLuego (0 \le i + 1 \le |ciudades| \land res = \sum\nolimits_{j=0}^{i} ciudades[j].habitantes))\\
	\equiv wp(res := res + ciudades[i].habitantes, 0 \le i + 1 \le |ciudades| \land res = \sum\nolimits_{j=0}^{i} ciudades[j].habitantes)\\
	\overset{\text{AX1}}{\equiv} def(ciudades[i].habitantes) \yLuego (0 \le i + 1 \le |ciudades| \land res + ciudades[i].habitantes = \sum\nolimits_{j=0}^{i} ciudades[j].habitantes)\\
	\equiv 0 \le i < |ciudades| \yLuego (-1 \le i < |ciudades| \land res + ciudades[i].habitantes = \sum\nolimits_{j=0}^{i} ciudades[j].habitantes)\\
	\equiv 0 \le i < |ciudades| \yLuego res  = \sum\nolimits_{j=0}^{i - 1} ciudades[j].habitantes + ciudades[i].habitantes - ciudades[i].habitantes\\
	\equiv 0 \le i < |ciudades| \yLuego res = \sum\nolimits_{j=0}^{i - 1} ciudades[j].habitantes$
	\vspace{0.3cm}\\
	Finalmente, veamos que $\{I \land B\} \implies wp(S,I)$\\
	$(0 \le i \le |ciudades| \land res = \sum\nolimits_{j=0}^{i - 1} ciudades[j].habitantes \land i < |ciudades|) \implies wp(S,I)$\\
	$(0 \le i < |ciudades| \land res = \sum\nolimits_{j=0}^{i - 1} ciudades[j].habitantes) \implies (0 \le i < |ciudades| \yLuego res = \sum\nolimits_{j=0}^{i - 1} ciudades[j].habitantes)$\\
	El predecente y el consecuente de esta implicacai\'on son id\'enticos, por lo tanto es una tautolog\'ia. \checkmark
	\item $I \land \neg B \implies Q_{c}\\
	(0 \le i \le |ciudades| \land res = \sum\nolimits_{j=0}^{i - 1} ciudades[j].habitantes \land i \ge |ciudades|) \implies Q_{c}\\
	(|ciudades| \le i \le |ciudades| \land res = \sum\nolimits_{j=0}^{i - 1} ciudades[j].habitantes|) \implies Q_{c}\\
	(i = |ciudades| \land res = \sum\nolimits_{j=0}^{i - 1} ciudades[j].habitantes|) \implies Q_{c}\\
	res = \sum\nolimits_{j=0}^{|ciudades| - 1} ciudades[j].habitantes \implies res = \sum\nolimits_{j=0}^{|ciudades| - 1} ciudades[j].habitantes\\$
	De nuevo, el predecente y el consecuente de esta implicacai\'on son id\'enticos, por lo tanto es una tautolog\'ia. \checkmark
\end{enumerate}
Queda demostrado parcialmente el progama. Para demostrar que este es v\'alido utilizaremos el teorema de terminaci\'on. 
Proponemos la siguiente funci\'on variante:\\
\begin{equation}
		f_{v} = |ciudades| - i
	\end{equation}

	\begin{enumerate} \setlength\itemsep{0cm}
		\item $\{I \land B \land v_{0} = f_{v}\}S\{f_{v} < v_{0}\} \iff \{I \land B \land v_{0} = f_{v}\} \implies wp(S, f_{v} < v_{0})$
		\vspace{0.3cm}\\
		Buscamos $wp(S, f_{v} < v_{0}) \equiv\\$
		$\equiv wp(S1;S2, |ciudades| - i < v_{0})\\
		\overset{\text{AX3}}{\equiv} wp(S1, wp(S2, |ciudades| - i < v_{0}))\\
		\equiv wp(S1, wp(i := i + 1, |ciudades| - i < v_{0}))\\
		\overset{\text{AX1}}{\equiv} wp(S1, def(i + 1) \yLuego |ciudades| - (i + 1) < v_{0})\\
		\equiv wp(res := res + ciudades[i].habitantes, |ciudades| - i - 1 < v_{0})\\
		\overset{\text{AX1}}{\equiv} def(res + ciudades[i].habitantes) \yLuego |ciudades| - i - 1 < v_{0}\\
		\equiv 0 \le i < |ciudades| \yLuego |ciudades| - i - 1 < v_{0}$
		\vspace{0.3cm}\\
		Finalmente, veamos que $\{I \land B \land v_{0} = f_{v}\} \implies wp(S, f_{v} < v_{0})\\
		(0 \le i \le |ciudades| \land \underline{res = \sum\nolimits_{j=0}^{i - 1} ciudades[j].habitantes} \land i < |ciudades| \land v_{0} = |ciudades| - i) \implies wp(S, f_{v} < v_{0})\\
		(0 \le i < |ciudades| \land v_{0} = |ciudades| - i) \implies (0 \le i < |ciudades| \yLuego |ciudades| - i - 1 < v_{0})$
		\begin{itemize}
			\item $0 \le i < |ciudades| \implies 0 \le i < |ciudades| \ \checkmark$
			\item $v_{0} = |ciudades| - i \implies |ciudades| - i - 1 < |ciudades| - i \iff - 1 < 0 \ \checkmark$
		\end{itemize}
		\item $I \land f_{v} \le 0 \implies \neg B\\
		(0 \le i \le |ciudades| \land \underline{res = \sum\nolimits_{j=0}^{i - 1} ciudades[j].habitantes} \land |ciudades| - i \le 0) \implies i \ge |ciudades|\\
		(0 \le i \le |ciudades| \land |ciudades| \le i) \implies i \ge |ciudades|\\
		|ciudades| \le i \le |ciudades| \implies i \ge |ciudades|\\
		i = |ciudades| \implies i \ge |ciudades| \ \checkmark$
	\end{enumerate}
	Aclaraci\'on: En estos dos \'ultimos \'items se ignora el valor de res en el momento de demostrar la implicaci\'on final porque no es relevante
	para la validez de esta. Los dos casos fueron \underline{subrayados}.
	
\subsection{Ejercicio 2}
En el requiere se incluye la condici\'on
	\begin{equation}
		\existe[unalinea]{i}{\ent}{0 \le i < |ciudades| \yLuego ciudades[i].habitantes > 50.000}
	\end{equation}
	Ya que vimos que el programa funciona con respecto a su especificaci\'on, entonces este n\'umero mayor a 50.000 ser\'a sumado. 
	La \'unica forma de que la sumatoria total no sea mayor a 50.000 ser\'ia si existiera alg\'un numero negativo entre los que se suman.
	Sabemos que esto no sucede gracias a otro de los requiere: 
	\begin{equation}
		\paraTodo[unalinea]{i}{\ent}{0 \le i < |ciudades| \implicaLuego ciudades[i].habitantes \ge 0}
	\end{equation}
Por lo tanto, el progama siempre devuelve un n\'umero mayor a 50.000.

\vspace{4cm}
	ACÁ TERMINA EL TP IGNOREN LO QUE SIGUE, LO DEJE POR SI ME SIRVE DESPUES PARA HACER ALGO MÁS 
	
	\vspace{4cm}

Lo principal: las fórmulas. Se puede poner en una linea, como $x_i = x_{i-1} + x_{i-2}$, o ponerse más grande:

\begin{equation}
	\sum\limits_{i=0}^{n} i
	\label{eq:1}
\end{equation}

Y se pueden citar ecuaciones con \verb|\eqref{nombreDeEq}|: \eqref{eq:1}

Ejemplo de itemizado:

\begin{itemize}
	\item Item 1
	\item Item 2
	\item Item 3
\end{itemize}

Ejemplo de enumerado con menor distancia entre items:

\begin{enumerate} \setlength\itemsep{0cm}
	\item Item 1
	\item Item 2
	\item Item 3
\end{enumerate}

Podemos escribir mucho texto. Mucho texto. Mucho texto. Mucho texto. Mucho texto. Mucho texto. Mucho texto. Mucho texto. Mucho texto. Mucho texto. Mucho texto.

Otro párrafo. Otro párrafo. Otro párrafo. Otro párrafo. Otro párrafo. Otro párrafo. Otro párrafo. Otro párrafo. Otro párrafo. Otro párrafo. Otro párrafo. Otro párrafo. Otro párrafo.

\vspace{0.3cm}

Le agregamos una separación entre párrafos. Le agregamos una separación entre párrafos. Le agregamos una separación entre párrafos. Le agregamos una separación entre párrafos. Le agregamos una separación entre párrafos.

\vspace{0.3cm}

La tabla \ref{tab:ejemplo} es un ejemplo de cómo se hace una tabla.

\begin{table}[h!]
	\centering
	\begin{tabular}{||l c c r||} 
		\hline
		Col1 & Col2 & Col2 & Col3 \\ [0.5ex] 
		\hline\hline
		1 & 6 & 87837 & 787 \\ 
		2 & 7 & 78 & 5415 \\
		3 & 545 & 778 & 7507 \\
		4 & 545 & 18744 & 7560 \\
		5 & 88 & 788 & 6344 \\
		\hline
	\end{tabular}
	\caption{Ejemplo de tabla}
	\label{tab:ejemplo}
\end{table}


La figura \ref{fig:subfigs} es un ejemplo de cómo se agrega una imagen.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.6\textwidth]{logo_dc.jpg}
	\caption{Ejemplo de figura}
	\label{fig:ejemplo}
\end{figure}

\begin{figure}[ht!]
	\begin{subfigure}{0.5\textwidth}
		\includegraphics[width=0.9\linewidth]{LaTeX-project} 
		\caption{Logo de LaTeX}
		\label{fig:subfig1}
	\end{subfigure}
	\begin{subfigure}{0.5\textwidth}
		\includegraphics[width=0.7\linewidth]{TeX}
		\caption{Logo de TeX}
		\label{fig:subfig2}
	\end{subfigure}
	\caption{Ejemplo para poner dos figuras juntas. Y citarlas por separado a (\subref{fig:subfig1}) y (\subref{fig:subfig2}).}
	% OJO: el caption siempre va antes del label
	\label{fig:subfigs}
\end{figure}



% Para hacer que quede todo en una misma linea, se puede usar minipage
%\begin{minipage}[t]{\textwidth}
	\begin{lstlisting}[caption={Ejemplo de código (usando los estilos de la cátedra, ver las macros para más detalles)},label=code:for]
res := 0;
i := 0;
while (i < s.size()) do
	res := res + s[i];
	i := i + 1
endwhile
	\end{lstlisting}
%\end{minipage}

Si se pone un label al \verb|lstlisting|, se puede referenciar: Código \ref{code:for}.


\subsection{Macros de la cátedra para especificar}

\begin{proc}{nombre}{\In paramIn : \nat, \Inout paramInout : \TLista{\ent}}{tipoRes}
	%    \modifica{parametro1, parametro2,..}
	\requiere{expresionBooleana1}
	\asegura{expresionBooleana2}
	\aux{auxiliar1}{parametros}{tipoRes}{expresion}
	\pred{pred1}{parametros}{expresion} 
\end{proc}

\aux{auxiliarSuelto}{parametros}{tipoRes} {\sum\limits_{i=0}^{n} i}

% \paraTodo{variable}{tipo}{expresion}
% \existe{variable}{tipo}{expresion}
% Pueden tener [unalinea] para que no se divida en varias lineas
\pred{predSuelto}{parametros}{\paraTodo[unalinea]{variable}{tipo}{algo \implicaLuego expresion}}
\pred{predSuelto}{parametros}{\existe[unalinea]{variable}{tipo}{(p \land q) \implicaLuego (r \yLuego s)}}



\end{document}
